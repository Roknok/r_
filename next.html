<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Fluid Snake Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: white;
      font-family: 'Arial', sans-serif;
    }

    #scoreContainer {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 1;
      pointer-events: none;
    }

    #reachText {
      font-size: 48px;
      color: #777;
      margin-bottom: 10px;
    }

    #score {
      font-size: 64px;
      color: black;
      font-weight: bold;
    }

    #endScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(255,255,255,0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s ease;
    }

    #endScreen.show {
      opacity: 1;
      pointer-events: all;
    }

    #endScreen h1 {
      font-size: 3em;
      margin-bottom: 20px;
      color: #333;
    }

    #endScreen button {
      padding: 10px 20px;
      font-size: 1.2em;
      background: #222;
      color: #ff0;
      border: 2px solid #ff0;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255,255,0,0.5);
    }
    #game{
      position: absolute;
      z-index: 2;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<div id="scoreContainer">
  <div id="reachText">Reach 50</div>
  <div id="score">Score: 0</div>
</div>

<div id="endScreen">
  <h1>PROCEED</h1>
  <button onclick="location.href='next2.html'">Go</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const scoreEl = document.getElementById('score');
const endScreen = document.getElementById('endScreen');

let score = 0;
let food = [];
let snakes = [];
let floatingTexts = [];

const background = document.createElement('canvas');
background.width = canvas.width;
background.height = canvas.height;
const bgCtx = background.getContext('2d');

function randomColor() {
  const hue = Math.floor(Math.random() * 360);
  return `hsl(${hue}, 80%, 60%)`;
}

class Snake {
  constructor(x, y, color) {
    this.head = { x, y };
    this.segments = [];
    this.length = 10;
    this.color = color;
    this.speed = 0.0009963215080747239*Math.sqrt(window.innerHeight*window.innerHeight + window.innerWidth*window.innerWidth)
    this.target = null;
    for (let i = 0; i < this.length; i++) {
      this.segments.push({ x: x - i * 8, y });
    }
  }

  findTarget(availableFoods, claimedTargets) {
    let closest = null;
    let closestDist = Infinity;
    for (let f of availableFoods) {
      if (claimedTargets.has(f)) continue;
      const d = (f.x - this.head.x) ** 2 + (f.y - this.head.y) ** 2;
      if (d < closestDist) {
        closestDist = d;
        closest = f;
      }
    }
    this.target = closest;
    if (closest) claimedTargets.add(closest);
  }

  update() {
    if (!this.target) return;

    const dx = this.target.x - this.head.x;
    const dy = this.target.y - this.head.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const vx = (dx / dist) * this.speed;
    const vy = (dy / dist) * this.speed;

    this.head.x += vx;
    this.head.y += vy;
    this.segments.unshift({ x: this.head.x, y: this.head.y });

    if (this.segments.length > this.length * 10) {
      this.segments.pop();
    }

    food = food.filter(f => {
      const d = Math.hypot(f.x - this.head.x, f.y - this.head.y);
      if (d < 25) {
        floatingTexts.push({
          x: f.x,
          y: f.y,
          text: "-1",
          color: "red",
          opacity: 1
        });
        score -= 1;
        updateScore();
        return false;
      }
      return true;
    });

    if (!food.includes(this.target)) {
      this.target = null;
    }
  }

  draw() {
    if (this.segments.length < 2) return;

    ctx.save();
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.lineWidth = 20;
    ctx.strokeStyle = this.color;

    ctx.beginPath();
    ctx.moveTo(this.segments[0].x, this.segments[0].y);

    for (let i = 1; i < this.segments.length - 1; i++) {
      const p1 = this.segments[i];
      const p2 = this.segments[i + 1];
      const cx = (p1.x + p2.x) / 2;
      const cy = (p1.y + p2.y) / 2;
      ctx.quadraticCurveTo(p1.x, p1.y, cx, cy);
    }

    ctx.stroke();
    ctx.restore();
  }
}

function spawnFood() {
  const radius = 18;
  const margin = radius + 5; // safe margin to keep inside bounds and away from each other
  const minDist = radius * 2 + 10; // minimum distance between foods

  while (food.length < 3) {
    const x = Math.random() * (canvas.width - 2 * margin) + margin;
    const y = Math.random() * (canvas.height - 2 * margin) + margin;

    let overlaps = false;
    for (let f of food) {
      const d = Math.hypot(f.x - x, f.y - y);
      if (d < minDist) {
        overlaps = true;
        break;
      }
    }

    if (!overlaps) {
      const color = randomColor();
      food.push({ x, y, color });
    }
  }
}


function drawFood() {
  for (let f of food) {
    ctx.beginPath();
    ctx.fillStyle = f.color;
    ctx.arc(f.x, f.y, 18, 0, Math.PI * 2);
    ctx.fill();
  }
}

function updateScore() {
  scoreEl.textContent = `Score: ${score}`;
  if (score >= 30 && snakes.length === 1) {
    snakes.push(new Snake(300, 300, "#00cc66"));
  }
  if (score >= 40 && snakes.length === 2) {
    snakes.push(new Snake(600, 200, "#ff9900"));
  }
}

function updateFloatingTexts() {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y -= 1;
    t.opacity -= 0.02;
    if (t.opacity <= 0) {
      floatingTexts.splice(i, 1);
      continue;
    }
    ctx.save();
    ctx.globalAlpha = t.opacity;
    ctx.fillStyle = t.color;
    ctx.font = "24px Arial";
    ctx.fillText(t.text, t.x, t.y);
    ctx.restore();
  }
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(background, 0, 0);

  spawnFood();
  drawFood();

  const claimed = new Set();
  for (let s of snakes) {
    if (!s.target || !food.includes(s.target)) {
      s.findTarget(food, claimed);
    }
  }

  for (let snake of snakes) {
    snake.update();
    snake.draw();
  }

  updateFloatingTexts();
  requestAnimationFrame(animate);
}

canvas.addEventListener("click", e => {
  food = food.filter(f => {
    const d = Math.hypot(f.x - e.clientX, f.y - e.clientY);
    if (d < 25) {
      score += 1;
      updateScore();

      floatingTexts.push({
        x: f.x,
        y: f.y,
        text: "+1",
        color: "green",
        opacity: 1
      });

      for (let i = 0; i < 30; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * 40;
        const px = e.clientX + Math.cos(angle) * dist;
        const py = e.clientY + Math.sin(angle) * dist;
        const size = Math.random() * 6 + 2;
        bgCtx.beginPath();
        bgCtx.fillStyle = f.color.replace('hsl', 'hsla').replace(')', ', 0.3)');
        bgCtx.arc(px, py, size, 0, Math.PI * 2);
        bgCtx.fill();
      }

      if (score >= 50) {
        endScreen.classList.add("show");
      }
      return false;
    }
    return true;
  });
});

snakes.push(new Snake(200, 200, "#3333ff"));
animate();
</script>

</body>
</html>
